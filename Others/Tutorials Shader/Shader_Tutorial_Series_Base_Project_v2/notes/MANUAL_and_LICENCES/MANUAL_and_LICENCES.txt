-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
						SHADER TESTER MANUAL
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------



-------------------------------------------------------------------------------
---------- LICENSES: ----------------------------------------------------------
-------------------------------------------------------------------------------
CC-Links:
	CC0:			https://creativecommons.org/publicdomain/zero/1.0/
	CC-BY 3.0:		https://creativecommons.org/licenses/by/3.0/
	CC-BY-4.0:		https://creativecommons.org/licenses/by/4.0/
	CC-BY-SA 3.0:	https://creativecommons.org/licenses/by-sa/3.0/
	GPL3:			https://www.gnu.org/licenses/gpl-3.0.html


All Fotos in Assetfolder "by Reverend Greg": CC-BY-SA 3.0
	by Gregor Ittensohn aka Reverend Greg (me)
	Credit with link to twitter
	Link to twitter: https://twitter.com/GamingReverends

All Fotos in Asset Folder "Pexels": CC0
	by various fotographers
	No credits needed
	Pexels: https://www.pexels.com/

All code: No specific license to refer to
	Free to use in comercial projects.
	Selling the code like i.e. in an asset store is not allowed.
	No credits needed unless creits mentioned in a script or shader code.
	
Jumper Pack: CC0
	by Kenney Vleugels for Kenney (www.kenney.nl)
	Quote from OGA page:
		"You may use these textures/photographs in personal and commercial projects.
	Credit (Kenney or www.kenney.nl) would be nice but is not mandatory."
	Donate:   http://support.kenney.nl
	Request:  http://request.kenney.nl
	Follow on Twitter for updates: @KenneyWings

Outdoor Tiles Again: CC-BY 3.0
	by Michele "Buch" Buchelli
	Qute from OGA page:
		"Credit me as Michele "Buch" Bucelli and link back to my OGA profile page"
	Asset OGA: https://opengameart.org/content/outdoor-tiles-again
	Artist OGA: https://opengameart.org/users/buch

GothicVania Town: CC-BY 3.0
	by ansimuz aka Luis Zuno
	Credit with this link: ansimuz.com
	Asset OGA: https://opengameart.org/content/gothicvania-town
	Artist OGA: https://opengameart.org/users/ansimuz
	Patreon: https://www.patreon.com/ansimuz

Square Block Textures: CC0
	by stqws3
	Asset OGA: https://opengameart.org/content/square-block-textures
	Artist OGA: https://opengameart.org/users/etqws3

Graveyard Platform Tileset: CC0
	by pzUH
	Asset OGA: https://opengameart.org/content/free-graveyard-platformer-tileset
	Artist OGA: https://opengameart.org/users/pzuh

Ninja: CC0
	by pzUH
	Asset OGA: https://opengameart.org/content/ninja-run-free-sprites
	Artist OGA: https://opengameart.org/users/pzuh
	
Gumbot: CC0
	by GrafxKid
	Asset OGA: https://opengameart.org/content/gum-bot-sprites
	Artist OGA: https://opengameart.org/users/grafxkid

Sapceships: CC-BY 3.0
	by Jerom
	Asset OGA: https://opengameart.org/content/retro-spaceships
	Artist OGA: https://opengameart.org/users/jerom

Spacegame Art Pack: CC-BY-SA 3.0
	by Tatermand
	Quote from OGA page:
		"used this art in your project? Please, send me a note and maybe a some 
		free copy of your game :) tatermand@gmail.com"
	Asset OGA: https://opengameart.org/content/space-game-art-pack-extended
	Artist OGA: https://opengameart.org/users/tatermand

Resident Evil I (red cap): license not specified
	by Double Leggy
	Quote from deviantart page:
		"You can download them and use them for whatever you like; sprite animation or RPG maker.
		All I ask is credit and a link back to this original deviation."
	Asset DA: https://doubleleggy.deviantart.com/art/RE1-Sprites-v1-0-148697818
	Artist DA: https://doubleleggy.deviantart.com/

GreenCap: CC0
	by isaiah658
	Quote from OGA page:
		"Credit to isaiah658 is not required but appreciated."
	Asset OGA: https://opengameart.org/content/green-cap-character-16x18
	Artist OGA: https://opengameart.org/users/isaiah658

Forest Platformer Pack: CC0
	by Tio Aimar
	Quote from OGA page:
		"Credit "Tio Aimar @ opengameart.org" or simply "Tio Aimar" (this is not mandatory)"
	Asset OGA: https://opengameart.org/content/2d-platformer-forest-pack
	Artist OGA: https://opengameart.org/users/tio-aimar

Cat n Dog (just cat in here): CC0
	by pzUH
	Asset OGA: https://opengameart.org/content/cat-dog-free-sprites
	Artist OGA: https://opengameart.org/users/pzuh

Sunny Land & Forest: CC0
	by ansimuz
	Credit: by Ansimuz

	Assets OGA:
		https://opengameart.org/content/sunny-land-2d-pixel-art-pack
		https://opengameart.org/content/sunnyland-forest
	Artis OGA: https://opengameart.org/users/ansimuz
	Patreon: https://www.patreon.com/ansimuz

A Blocky Dungeon:
	by Michele "Buch" Buchelli
	Copyright/Attribution Notice on OGA page:
		"NOT REQUIRED, though appreciated: credit me as Buch and link back either to 
		http://blog-buch.rhcloud.com or to my OGA profile page."
	Asset OGA: https://opengameart.org/content/a-blocky-dungeon
	Artis OGA: https://opengameart.org/users/buch

Mage City: CC0
	by Hyptosis
	Quote on OGA page:
		"Feel free to use it for anything, you can even make profit. If you want please give 
		me credit for the tile though as 'Hyptosis' or link to www.lorestrome.com if you want. 
		But you're not obligated to. Everyone should be able to make games, I hope these help."
	Asset OGA: https://opengameart.org/content/mage-city-arcanos
	Artist OGA: https://opengameart.org/users/hyptosis

ELF LPC: GPL3 and CC-BY-SA3 
	created with LPC Character Generator: http://gaurav.munjal.us/Universal-LPC-Spritesheet-Character-Generator/#
	Credits: http://gaurav.munjal.us/Universal-LPC-Spritesheet-Character-Generator/Universal-LPC-spritesheet/AUTHORS.txt


All of theses assets may have been changed by me in one or the other way.
So if you want to use an aaest you best grab the original as linked above.

To all these changed assets apply the same licenses as for the original.

If you reuse the altered versions and want to or need to give credits to the 
original artist, mention that these are altered versions (in case the original 
artist isn't happy with the changes).

No need to additionally credit me though.




-------------------------------------------------------------------------------
---------- ROOMS: -------------------------------------------------------------
-------------------------------------------------------------------------------
IMPORTANT:  Do not create new rooms. Always create a child of the
			template room.
The name of the room as shown by obj_room_name is:
- the rooms asset name minus the first 3 charaters (i.e. minus "rm_")
- every "_" is replaced by " "
- every "xx" is replaced by "|"
	
First instance created has to be the controller obj_game_controller. If you
just create a child of the tempalte room this should always be true anyways.

The modules need to be created after the gui buttons and sliders. so if you 
add new buttons and sliders, make sure to move the modules down in the 
instance creation order.



-------------------------------------------------------------------------------
---------- MODULES: -----------------------------------------------------------
-------------------------------------------------------------------------------
The modules are used to test shaders very quickly because many things needed
for testing are implemented already.

Duplicate this template module to create a new test module and place the
duplicate in the test room.
Most shader tests can be done with a test module like this. In some cases 
however it might make sense to use a duplicate of the player template instead.

You can add multiple modules in one test room. Every module will run its 
shader and so it's easy to compare different but similar shader types. 
Each module can be selected by clicking on it and the info text box swill show 
the infotext of the selected module. If you want only one shader to run its 
code at any given time, add
	if (global.selected_module == id)
to each modules drawing code.

If only one module is in the test room it will be selected automatically.


Title, Info, Corner, Click:
---------------------------------------
Usually when testing a shader you'll draw a sprite. Using a module to test
allows to quickly add a frame around the sprite, add a title text above the
sprite, some info text to draw in the infor text box of the gui and some
additional info on top of the sprite - called corner info.

The corner info is used to display current settings like effect strength for
this module. Usually the corner info is the only thing you want to change 
dynamically i.e. in a step event.

To be able to select and deselect a module by clicking on it you need to set 
the click region to either gui or room coordinates depending on where you draw
the sprite and frame. You can set that with the variable
	click_region_gui (true/false)
	
In rare cases you might not want to be able to deselect a module (i.e. if you
are using a mockup game with a player object and want to control the player
with the mouse or touchscreen. You can disaable deselecting with the variable
	deselectable = false;


Sprite & Shader:
---------------------------------------
This is the main part of the tests. Here you can set up the sprite, shader and
its uniforms.

The variable named "sprite" is used by the module to determine the size of the
module frame. If you don't set one, the parent object set's a 1x1 px 
transparent sprite.

However the project file provides several fotos of different sizes to test
shaders with. You can find the in the ressource tree:
	Sprites > Base Project > Images


Resize View and Application Surface:
---------------------------------------
Entirely optional.
Here you can set a zoom level i.e. if you want to test a shader on pixel art.
Just mind that if you scale the view and applicaton surface you might want to
draw the module frame to the gui and not in room space.


Parent
---------------------------------------
The modules are children of par_module.

The parent sets up some important variables in its create event. Thus this
event should always bne inherited.

The alarm0 event finalizes the setup is mandatory as well. So do not use alarm0
in the test module.

The step event is used to select or deselct a module and thus is not needed if
you do not want that functionality.




-------------------------------------------------------------------------------
---------- LAYERS: ------------------------------------------------------------
-------------------------------------------------------------------------------
The template room has several layers with specific purposes:

- ilyr_main:			is where the controllers are and where we usually place 
						our test modules.
- ilyr_gui_dynamic:		is where dynamic gui elements like buttons and sldiers 
						go. Learn more about dynamic hui elements in this manual 
						a few sections below.
- alyr_layout:			Shows some cross hairs to place the test modules upon.
							- orange:	space for 6 square 256px modules
							- yellow:	space for 4 wide 400x256px modules
							- green:	space for 3 tall 256x512px modules
							- red:	center of the screen
- ilyr_modifiers:		is where all modifiers are. Learn more about modifiers 
						in this manual a few sections below.
- ilyr_gui_essentials:	is where some essential gui elemnts are. BEst not touch 
						it.  Learn more about essential gui elements in this 
						manual a few sections below.
- ilyr_darken:			is darkening the screen where the gui is. Can be moved 
						or set invisible.
- tlyr_blur grid: 		can be set invisible.
- blyr_blank:			can be set invisible




-------------------------------------------------------------------------------
---------- ESSENTIAL GUI ELEMENTS: --------------------------------------------
-------------------------------------------------------------------------------
The GUI elements should be in every room (although don't necessarily have to)
and are placed on a layer reserved for them.


Info Text:
---------------------------------------
This object draws a text box showing the info text of the selected module or 
some instructional text when no module is selected.

The size of the textbox can be set in the room editor by dragging the sides of 
the place holder sprite.


Room Name:
---------------------------------------
This object draws the room name to the gui.

The width available to the text is determined by the place hodler sprite in the
room editor. You can change the size by dragging its sides. If the text won't
fit, the tail is cut off.

The name of the room as shown in the program is:
- the rooms asset name minus the first 3 charaters (i.e. minus "rm_")
- every "_"   is replaced by " "
- every "xxv" is replaced by "|" -> vertical line
- every "xxh" is replaced by "-" -> horizontal line
- every "xxd" is replaced by "." -> dot
- every "xxc" is replaced by "," -> comma
- every "xxa" is replaced by "&" -> and
- every "xxs" is replaced by "/" -> slash


Room Number:
---------------------------------------
This object draws the room number and number of rooms to the gui.


FPS:
---------------------------------------
This object draws fps, fps-real and a bar indicating when the text gets 
updated again as a visual feedback of the performace.


Next/Previous Room:
---------------------------------------
These objects switch to the next or previous room.
Room 0 is skipped because that is the template room.
Do not create any other rooms than children of the tempalte room.


Show/Hide GUI:
---------------------------------------
Toggles visibility of specific objects like:
- par_btn
- obj_room_name
- obj_room_number
- obj_fps

The visibility of the gui can also be toggled with the script:
	gui_set_visible(true/false);


Automate Slider:
---------------------------------------
This object toggles the automation type of a slider instance.

IMPORTANT:
Do not place an instance of this object yourself. It will be created by the
slider object to the left or right of the slider depending on where the 
centre of the slider is:
	- slider center < GUI center -> automation button right of slider
	- slider center > GUI center -> automation button left of slider
If you don't want the automation button, place a kill modifier over the  
area where the automation button would appear.




-------------------------------------------------------------------------------
---------- DYNAMIC GUI ELEMENTS: ----------------------------------------------
-------------------------------------------------------------------------------
The dynamic GUI elements are meant to interact with the modules.

The template room has
- 5 sliders
	but as many as you want can be added.
- 6 trigger buttons
	but as many as you want can be added.
- 15 toggle buttons
	You can have 10 toggle buttons per toggle group and 10 toggle groups.
	Exceeding this number crashes the program.
	You can however indcrease both limits in create event of obj_game_control
	where the ds_grid global.toggle is created.
	

Slider:
---------------------------------------
This object creates a slider and a button to automate the slider.

To set the width of the slider, just drag out its sides in the room editor.
The automation button is created to the right or left of the slider,
depending on where the centre of the slider is:
- slider center < GUI center -> automation button right of slider
- slider center > GUI center -> automation button left of slider

If you don't want the automation button, place a kill modifier over the  
area where the automation button would appear.

There are several setter scripts to change the slider:
- slider_set_value:				real, 0 <= value <= 1
- slider_set_caption:			string
								can be "" to draw no caption
- slider_set_sprite:			sprite id
- slider_set_automation_speed:	real, 0 < automation_speed < 1
								lower = slower
								0 would mean no movement which can be toggled 
									by the automation button
								> 0.1 is very fast already
- slider_set_automation_type:	0: off
								1: back and forth
								2: cycle
- slider_set_draw_value:		boolean
								draw the value onto the slider button?

And several getter scripts:
- slider_get_id					sliders instance id
- slider_get_value				real, 0 <= value <= 1
- slider_get_caption			string
- slider_get_automation_speed	real, 0 < automation_speed < 1
- slider_get_draw_value			boolean
- slider_get_released			boolean
								whether the slider was just released
- slider_get_pressed			boolean
								whether the slider was just pressed


Trigger:
---------------------------------------
This object creates a button to trigger some action.

There are several setter scripts to change the trigger button:
- trigger_set_caption:			string
								can be "" to draw no caption
- trigger_set_sprite:			sprite id

And several getter scripts:
- trigger_get_id				triggers instance id
- trigger_get_caption			string
- trigger_get_released			boolean
								whether the trigger was just released
- trigger_get_pressed			boolean
								whether the trigger was just pressed


Toggle:
---------------------------------------
This object is used to create a toggle button.

When pressing a toggle button each toggle button in the same toggle group 
is toggled off in a group.

Use the toggle group modifier in the room editor to assign the toggle button 
to a toggle group: i.e. every toggle button colliding with the modifier TG01
will be assigned to the toggle group 1.
Ih there's no toggle modifier coliding, the toggle button will be assigned
toggle group 0.

IMPORTANT:
	You can have 10 toggle buttons per toggle group and 10 toggle groups.
	Exceeding this number crashes the program.
	You can however indcrease both limits in create event of obj_game_control
	where the ds_grid global.toggle is created.

There are several setter scripts to change the toggle button:
- toggle_set_caption:			string
								can be "" to draw no caption
- toggle_set_sprite:			sprite id

And several getter scripts:
- toggle_get_id					toggle buttons instance id
- toggle_get_state				boolean, true: on | false: off
- toggle_get_group_active		toggle button number of the active button in a toggle group
								-1: if all are off
- toggle_get_caption			string
- toggle_get_released			boolean
								whether the button was just released
- toggle_get_pressed			boolean
								whether the button was just pressed




-------------------------------------------------------------------------------
---------- MODIFIERS: ---------------------------------------------------------
-------------------------------------------------------------------------------
Modifiers are placed on the modifier layer in the room editor. All modifiers
can be dragged over instance to modify those. The template room has several
modifier instances ready to move anywhere.
	-> no need to grab new instances from the ressource tree.

The modifiers automatically destroy themselves on the first frame.
	-> no need to delete the unused modifier instances in the room children.


KILL: kills instances of these objects:
---------------------------------------
	- trigger
	- toggle
	- slider
	- slider automation
	- fps		(optional, can be activated in create event of the obj_fps)
	- info text	(optional, can be activated in create event of obj_info_text)
	
	IMPORTANT:	The code to destroy the intances must be in the create event
				of these objects:
					if (instance_place(x, y, mod_KILL) != noone) {instance_destroy();exit;}
				The destroyed instances still run their create event up to that
				code. To prevent running the rest of the create event this code
				cannot by in the parents create event and not in a script.
	
	
TG[0-9]: sets the toggle groups of toggle buttons.
---------------------------------------
	Every toggle button without a toggle group overlapping will be in TG0.
	
	IMPORTANT:	In the rooms Instance creation order, this modifier needs to 
				always be created before the toggle buttons or the program will 
				crash.

				You can have 10 toggle buttons per toggle group and 10 toggle 
				groups. Exceeding this number crashes the program.
				You can however indcrease both limits in create event of 
				obj_game_control where the ds_grid global.toggle is created.




-------------------------------------------------------------------------------
---------- MOCKUPS: -----------------------------------------------------------
-------------------------------------------------------------------------------
There are 3 kind of systems and/or assets ready to use for creating mockup 
games in case we want to test a shader in action.


Tile Sets
---------------------------------------
	These are just a few tile set assets ready to use.

	Just create a tile layer in your test room and create the mockup yourself 
	by using these tile sets :)

	You can add a character (see next section in this manual) and collisions
	for that character with obj_wall.

	All the assets can be found here:
		Tile Sets > Base Project > Mockups


Single Sprite Environments
---------------------------------------
	These are just a few sprite assets usually created from tile Sets ready to 
	use as simple mockups.

	Just create a background layer and set the asset as sprite background.

	You can add a character (see next section in this manual) and collisions
	for that character with obj_wall.

	All the assets can be found here:
		Sprites > Base Project > Mockups > Single Sprite BG


Side Scroll Mockups
---------------------------------------
	These mockups are created from several parallax scrolling back- and foreground
	layers and a immobile moonwalking mockup character.

	All the assets can be found here:
		Sprites > Base Project > Mockups > Layered BG / Characters

	To use these mockups just call some scripts in create event of a test module
		To add a layer call:
			scr_add_mockup_scoll_layer(...)
	
		To add a character call:
			scr_add_mockup_character(...)
	
		Or instead to add a preset with layers and a character call:
			scr_use_template_mockup(...)

	
	Either of these scripts will create an object with a scrolling layer and/or
	a moonwaling character. You can set things like layer scrolls speed, character
	animation speed, scale & depth of the layer/character etc.
	
	More detailed information are in the mentioned scripts.


View/Camera scale:
---------------------------------------
We can also set the camera scale with the script:
	scr_camera_set_scale(scale factor)




-------------------------------------------------------------------------------
---------- PLAYER MOVEMENT & CAMERA: ------------------------------------------
-------------------------------------------------------------------------------
There is a template object and some scripts to handle player movement in case
we want to test some effects in action. It's just the movement though. No 
Fighting or other interaction.

There are also several characters ready to use. Their sprites can be found here:
	Sprites > Base Project > Mockups > Characters

And in case the room is not filling the view we can also set a camera to follow
the player.


Create a character:
---------------------------------------
	To create a character, all you need to do is:
		- duplicate the template object: obj_player_template
		- set it's properties in create event
		- place the object in your test room

	You will find some additonal instructions in the header of the create event.


Collisions:
---------------------------------------
	The player object does a collision check with obj_wall. So you can use
	those on any layer in the test room to create unpassable areas.


Controls:
---------------------------------------
	Topdown:
		Keyboard:	WASD, Arrows
		Gamepad*:	D-PAD, L-Stick
		Mouse:		Moves towards mouse when LMB is down
		Touch:		Moves towards finger while touching
	
	Left-Right:
		Keyboard:	AD, Arrows
		Gamepad*:	D-Pad, L-Stick
		Mouse:		Moves towards mouse when LMB is down
		Touch:		Moves towards finger while touching

	Platform:
		Keyboard:	AD, Arrows LR	to move
					Space, Arrow up	to jump
		Gamepad*:	D-Pad, L-Stick	to move
					F1 / A / Cross	to jump
		Mouse:		LMB				to move
					RMB				to jump
		Touch:		Tilt			to move
					Touch			to jump

	*) MOGA and generic gamepad (should) work on tablets as well
	
	
	
Camera:
---------------------------------------
There are 3 simpls scripts to control the camera:

	scr_camera_set_scale(scale factor)
		to set a zoom level
		
	scr_camera_set_scale
		to get the zoom level (i.e. to draw the app surface scaled)
	
	scr_camera_set_target(target instance id, follow speed)
		to let the camera follow an isntance. Usually the player instance.
		
	scr_camera_reset_target()
		to reset the camera position back to the upper left corner of the room.

	


-------------------------------------------------------------------------------
---------- THE END: -----------------------------------------------------------
-------------------------------------------------------------------------------







